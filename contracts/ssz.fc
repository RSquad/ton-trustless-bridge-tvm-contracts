#include "imports/stdlib.fc";
#include "utils/messages.fc";
#include "static/logs.fc";
#include "ssz/ssz_utils.fc";







;; ;; basic
;; hashTreeRoot(value: V): Uint8Array {
;;     // TODO: Optimize
;;     const uint8Array = new Uint8Array(32);
;;     const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
;;     this.value_serializeToBytes({uint8Array, dataView}, 0, value);
;;     return uint8Array;
;;   }

;; ;; bitList
;; hashTreeRoot(value: BitArray): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.bitLen);
;;   }



;; ;; byteList
;; hashTreeRoot(value: ByteArray): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; composite
;; hashTreeRoot(value: V): Uint8Array {
;;     // Return cached mutable root if any
;;     if (this.cachePermanentRootStruct) {
;;       const cachedRoot = (value as ValueWithCachedPermanentRoot)[symbolCachedPermanentRoot];
;;       if (cachedRoot) {
;;         return cachedRoot;
;;       }
;;     }

;;     const root = merkleize(this.getRoots(value), this.maxChunkCount);

;;     if (this.cachePermanentRootStruct) {
;;       (value as ValueWithCachedPermanentRoot)[symbolCachedPermanentRoot] = root;
;;     }

;;     return root;
;;   }



;; ;; listBasic
;; hashTreeRoot(value: ValueOf<ElementType>[]): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; listComposite
;; hashTreeRoot(value: ValueOf<ElementType>[]): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; union
;; hashTreeRoot(value: ValueOfTypes<Types>): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.selector);
;;   }

;; (leaf: Buffer, branch: Buffer[], depth: number, index: number, root: Buffer)
;; (slice) int_to_slice(value: int) {
;;   return begin_cell()
;;   .store_uint(value, 32 * 8)
;;   .end_cell().begin_parse();
;; }

(int) is_valid_merkle_branch (int leaf, tuple branch, int depth, int index, int root) impure {
  int value = leaf;
  int powRes = 1;

  repeat(depth) {
    slice value_slice = begin_cell().store_uint(value, 32 * 8).end_cell().begin_parse();
    if ((index / powRes) % 2 == 1) {
      value = sha_hash_2(branch~tpop(),value_slice);
    } else {
      value = sha_hash_2(value_slice, branch~tpop());
    }
    powRes = powRes * 2;
  }

  return (value == root) % 2;
}



(tuple) branch_to_tuple(slice branch) impure {
  tuple t = empty_tuple();
  slice items = branch~load_ref().begin_parse();

  while(items.slice_refs_empty?() == 0) {
    t = t.tpush(items~load_ref().begin_parse());
    if(items.slice_refs_empty?() == 0) {
      items = items~load_ref().begin_parse();
    }
  }
  return t;
}

(tuple) committee_branch_to_tuple(slice branch) impure {
  tuple t = empty_tuple();
  slice items = branch;

  t = t.tpush(items);
  while(items.slice_refs_empty?() == 0) {
    items = items~load_ref().begin_parse();
    t = t.tpush(items);
  }
  return t;
}

(int) aggregatePubkeyHashTreeRoot(slice cs, int print) impure {
  int padFor = 2;
  int count = 2;
  tuple filled = empty_tuple();
  int part1 = cs~load_uint(32 * 8);
  int part2 = cs~load_uint(16 * 8) << (16 * 8);
  filled = cons(part1, filled);
  filled = cons(part2, filled);

  if (print) {

  cell log_body = begin_cell()
        .store_uint(part1, 32 * 8)
        .store_uint(part2, 32 * 8)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);
  }

  int res = merkleize(filled, padFor, count);
  return res;
}

(int) next_sync_committee_pubkeys_hash_tree_root(slice cs) impure {
  cell pubkeys = cs~load_dict();
  ;; calculate hash of pubkeys
  ;; int i = 0;

  ;; (slice pub, int key) = pubkeys.udict_get?(32,i);
  ;; (int key, slice pub, int flag) = pubkeys.udict_get_max?(32);
  ;; cell log_body = begin_cell()
  ;;   .store_uint(0x010101, 32)
  ;;   ;; .store_uint(key & 0xffff, 128)
  ;;   .store_slice(pub)
  ;;   .end_cell();

  ;; emit_log_simple(log::wrap, log_body, 0);
  ;; (int key, slice val, int flag) = pubkeys.udict_get_min?(32);
  ;; slice originalKey = val;
  int key = 0;
  repeat(512) {
  ;; while(flag) {
    ;; int tmp_key = key;
    ;; (key, val, flag) = pubkeys.udict_get_next?(32, key);
    (slice val, int flag) = pubkeys.udict_get?(32, key);
    int hash = aggregatePubkeyHashTreeRoot(val, 0);
    slice hash_slice = begin_cell().store_uint(hash, 32 * 8).end_cell().begin_parse();
    pubkeys~udict_set(32, key, hash_slice);
    key = key + 1;
  }

  (slice item, int k) = pubkeys.udict_get?(32, 511);

  ;; cell log_body = begin_cell()
  ;;   ;; .store_uint(0x010101, 32)
  ;;   ;; .store_uint(key & 0xffff, 128)
  ;;   ;; .store_slice(originalKey)
  ;;   .store_uint(0x00, 16)
  ;;   .store_slice(item)
  ;;   ;; .store_dict(pubkeys)
  ;;   .end_cell();

  ;; emit_log_simple(log::wrap, log_body, 0);

  return merkelize_dict(pubkeys, 512, 512);
  ;; return merkelize_dict(pubkeys,2,50);
}

(int) verify_sync_comittee(slice cs, slice committee_slice, slice committee_pubs_slice) impure {
  slice attested_header = cs~load_ref().begin_parse();
  slice attested_header_fields = attested_header~load_ref().begin_parse();

  slice finalized_header = attested_header~load_ref().begin_parse();
  slice finalized_header_fields = finalized_header~load_ref().begin_parse();

  slice beacon = attested_header_fields~load_ref().begin_parse();
  ;; slice beacon_fields = beacon~load_ref().begin_parse();
  slice execution = attested_header_fields~load_ref().begin_parse();
  (slice next_field, slice execution_ssz_hash) = hashTreeRoot(execution);
  slice execution_fields = execution~load_ref().begin_parse();
  slice executionBranch = execution~load_ref().begin_parse();

  int execution_branch_length = 5;
  int index = 23;

  slice beacon_slot = beacon~load_ref().begin_parse();
  slice beacon_proposer_index = beacon_slot~load_ref().begin_parse();
  slice beacon_parent_root = beacon_proposer_index~load_ref().begin_parse();

  slice beacon_state_root = beacon_proposer_index~load_ref().begin_parse();
  slice beacon_state_root_data = beacon_state_root~load_ref().begin_parse();
  slice beacon_body_root = beacon_state_root~load_ref().begin_parse();
  slice beacon_body_root_data = beacon_body_root~load_ref().begin_parse();



  ;; slice res = beacon_state_root_data;
  tuple committee_bracch_tuple = committee_branch_to_tuple(committee_slice);

  int res = is_valid_merkle_branch(
    committee_pubs_slice~load_uint(32 * 8),
    committee_bracch_tuple,
    execution_branch_length,
    index,
    beacon_state_root_data~load_uint(32 * 8));


  cell log_body = begin_cell()
        ;; .store_slice(res)
        .store_uint(res, 32)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);

  return res;
}

(int) verify_receipt_root(slice cs) impure {
  ;; skip attestedHeader body

  slice attested_header = cs~load_ref().begin_parse();
  slice attested_header_fields = attested_header~load_ref().begin_parse();

  slice finalized_header = attested_header~load_ref().begin_parse();
  slice finalized_header_fields = finalized_header~load_ref().begin_parse();

  slice beacon = finalized_header_fields~load_ref().begin_parse();
  ;; slice beacon_fields = beacon~load_ref().begin_parse();
  slice execution = finalized_header_fields~load_ref().begin_parse();
  (slice next_field, slice execution_ssz_hash) = hashTreeRoot(execution);
  slice execution_fields = execution~load_ref().begin_parse();
  slice executionBranch = execution~load_ref().begin_parse();

  int execution_branch_length = 4;
  int index = 9;

  slice beacon_slot = beacon~load_ref().begin_parse();
  slice beacon_proposer_index = beacon_slot~load_ref().begin_parse();
  slice beacon_parent_root = beacon_proposer_index~load_ref().begin_parse();

  slice beacon_state_root = beacon_proposer_index~load_ref().begin_parse();
  beacon_state_root~load_ref();
  slice beacon_body_root = beacon_state_root~load_ref().begin_parse();
  slice beacon_body_root_data = beacon_body_root~load_ref().begin_parse();


  int res = is_valid_merkle_branch(execution_ssz_hash~load_uint(32 * 8), branch_to_tuple(executionBranch), execution_branch_length, index, beacon_body_root_data~load_uint(32 * 8));

  ;; tuple test = branch_to_tuple(executionBranch);

  ;; slice res = test~tpop();

  cell log_body = begin_cell()
        ;; .store_slice(res)
        .store_uint(res, 32)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);

  return res;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    if (op == op::run_ssz) {
      cell data = in_msg_body~load_ref();
      slice data_slice = data.begin_parse();

      slice res = data_slice~hashTreeRoot();

      cell log_body = begin_cell()
        ;; .store_uint(res, 32)
        .store_slice(res)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);
      return();
    }

    if (op == op::run_verify_receipt) {
      cell data = in_msg_body~load_ref();
      slice data_slice = data.begin_parse();
      cell committee_cell = in_msg_body~load_ref();
      slice committee_slice = committee_cell.begin_parse();
      cell committee_pubs = in_msg_body~load_ref();
      slice committee_pubs_slice = committee_pubs.begin_parse();
      cell committee_full = in_msg_body~load_ref();
      slice committee_full_slice = committee_full.begin_parse();

      ;; int res1 = verify_receipt_root(data_slice);
      ;; int res2 = verify_sync_comittee(data_slice, committee_slice, committee_pubs_slice);

      ;; committee_full_slice~load_ref();
      ;; int res3 = aggregatePubkeyHashTreeRoot(committee_full_slice, 0);
      cell pubkeys_dict = committee_full_slice~load_ref();
      int res4 = next_sync_committee_pubkeys_hash_tree_root(pubkeys_dict.begin_parse());
      cell log_body = begin_cell()
        ;; .store_uint(res1, 8)
        ;; .store_uint(res2, 8)
        .store_uint(res4, 32 * 8)
        ;; .store_slice(committee_full_slice)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);




      return ();
    }

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}
