#include "imports/stdlib.fc";
#include "utils/messages.fc";
#include "static/logs.fc";
#include "ssz/ssz_utils.fc";

builder store_endian4(builder b, int x) asm(x b) "STULE4";
builder store_endian8(builder b, int x) asm(x b) "STULE8";

const op::run_ssz = "op::run_ssz"c; ;; create an opcode from string using the "c" prefix, this results in 0x86f1bcc5 opcode in this case

const type::uint = "type::uint"c;
const type::bool = "type::bool"c;
const type::byteVector = "type::byteVector"c;
const type::bitVector = "type::bitVector"c;
const type::bitList = "type::bitList"c;
const type::byteList = "type::byteList"c;
const type::list = "type::list"c;
const type::vector = "type::vector"c;
const type::container = "type::container"c;

;; ;; basic
;; hashTreeRoot(value: V): Uint8Array {
;;     // TODO: Optimize
;;     const uint8Array = new Uint8Array(32);
;;     const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
;;     this.value_serializeToBytes({uint8Array, dataView}, 0, value);
;;     return uint8Array;
;;   }

;; ;; bitList
;; hashTreeRoot(value: BitArray): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.bitLen);
;;   }



;; ;; byteList
;; hashTreeRoot(value: ByteArray): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; composite
;; hashTreeRoot(value: V): Uint8Array {
;;     // Return cached mutable root if any
;;     if (this.cachePermanentRootStruct) {
;;       const cachedRoot = (value as ValueWithCachedPermanentRoot)[symbolCachedPermanentRoot];
;;       if (cachedRoot) {
;;         return cachedRoot;
;;       }
;;     }

;;     const root = merkleize(this.getRoots(value), this.maxChunkCount);

;;     if (this.cachePermanentRootStruct) {
;;       (value as ValueWithCachedPermanentRoot)[symbolCachedPermanentRoot] = root;
;;     }

;;     return root;
;;   }



;; ;; listBasic
;; hashTreeRoot(value: ValueOf<ElementType>[]): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; listComposite
;; hashTreeRoot(value: ValueOf<ElementType>[]): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; union
;; hashTreeRoot(value: ValueOfTypes<Types>): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.selector);
;;   }

(tuple) fill_tuple(tuple fill, cell data, int count) impure {
  slice cs = data.begin_parse();
  int value = cs~load_uint(32 * 8);
  count += 1;
  fill = cons(value, fill);
  ;; fill = fill.tpush(value);
  if (cs.slice_refs_empty?() == 0) {
    return fill_tuple(fill, cs~load_ref(), count);
  }
  return cons(count, fill);
}

(slice, slice) hashTreeRoot(slice cs) impure {
  ;; slice cs = value.begin_parse();
  int data_type = cs~load_uint(32);

  cell log_body = begin_cell()
        .store_uint(data_type, 32)
        .store_ref(
          begin_cell()
            .store_uint(cs.slice_refs(), 16)
          .end_cell()
        )
        .end_cell();

  emit_log_simple(log::wrap, log_body, 0);

  if (data_type == type::bool) {
    int data = cs~load_uint(1);
    return (cs, begin_cell()
    .store_uint(data, 8)
    .store_uint(0, 31 * 8)
    .end_cell()
    .begin_parse());
  }

  if (data_type == type::uint) {
    int isInf = cs~load_uint(1);
    int size = cs~load_uint(16);
    int data = cs~load_uint(size * 8);

    if (size == 1) {
      return (cs, begin_cell()
      .store_uint(data, size * 8)
      .store_uint(0, 31 * 8)
      .end_cell().begin_parse());
    }
    if (size == 2) {
      return (cs, begin_cell()
      .store_uint(data & 0xFF, 8)
      .store_uint(data / 0x100, 8)
      .store_uint(0, 30 * 8)
      .end_cell().begin_parse());
    }
    if (size == 4) {
      return (cs, begin_cell()
      .store_endian4(data)
      .store_uint(0, 28 * 8)
      .end_cell().begin_parse());
    }
    if (size == 8) {
      ;; if (isInf) {
      ;;   data = 0xffffffffffffffff;
      ;; }

      return (cs, begin_cell()
      .store_endian8(data)
      .store_uint(0, 24 * 8)
      .end_cell().begin_parse());
    }
  }
  if ((data_type == type::byteList)) {
    cell start = cs~load_ref();
    int padFor = cs~load_uint(32);
    int valueLength = cs~load_uint(64);
    int count = 0;
    tuple filled = fill_tuple(empty_tuple(), start, count);
    count = filled~list_next();

    int res = merkleize(filled, padFor, count);
    res = mix_in_length(res, valueLength);

    return (
      cs,
      begin_cell()
        .store_uint(res, 32 * 8)
      .end_cell()
      .begin_parse()
    );
  }

  if ((data_type == type::byteVector)) {
    cell start = cs~load_ref();
    int padFor = cs~load_uint(32);
    int valueLength = cs~load_uint(64);
    int count = 0;
    tuple filled = fill_tuple(empty_tuple(), start, count);
    count = filled~list_next();

    int res = merkleize(filled, padFor, count);
    ;; res = mix_in_length(res, valueLength);

    return (
      cs,
      begin_cell()
        .store_uint(res, 32 * 8)
      .end_cell()
      .begin_parse()
    );
  }

  if (data_type == type::container) {
    cell fields = cs~load_ref();
    tuple chunks = empty_tuple();

    int count = 0;
    slice fields_slice = fields.begin_parse();

    slice field_res = fields_slice~hashTreeRoot();
    int field_hash = field_res~load_uint(32 * 8);
    chunks = cons(field_hash, chunks);
    count += 1;

    while (fields_slice.slice_refs_empty?() == 0) {
      fields = fields_slice~load_ref();
      fields_slice = fields.begin_parse();

      slice field_res = fields_slice~hashTreeRoot();
      int field_hash = field_res~load_uint(32 * 8);

      chunks = cons(field_hash, chunks);
      count += 1;
    }

    int res = merkleize(chunks, count, count);

    return (cs, begin_cell()
    .store_uint(res, 32 * 8)
    .end_cell().begin_parse());
  }

  throw(1111);
  return (cs, begin_cell().end_cell().begin_parse());
}



() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    if (op == op::run_ssz) {
      cell data = in_msg_body~load_ref();
      slice data_slice = data.begin_parse();

      slice res = data_slice~hashTreeRoot();


      cell log_body = begin_cell()
        ;; .store_uint(res, 32)
        .store_slice(res)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);
      return();
    }

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}
