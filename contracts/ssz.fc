#include "imports/stdlib.fc";
#include "utils/messages.fc";
#include "static/logs.fc";
#include "ssz/ssz_utils.fc";

builder store_endian4(builder b, int x) asm(x b) "STULE4";
builder store_endian8(builder b, int x) asm(x b) "STULE8";

const op::run_ssz = "op::run_ssz"c; ;; create an opcode from string using the "c" prefix, this results in 0x86f1bcc5 opcode in this case
const op::run_verify_receipt = "op::run_verify_receipt"c;

const type::uint = "type::uint"c;
const type::bool = "type::bool"c;
const type::byteVector = "type::byteVector"c;
const type::bitVector = "type::bitVector"c;
const type::bitList = "type::bitList"c;
const type::byteList = "type::byteList"c;
const type::list = "type::list"c;
const type::vector = "type::vector"c;
const type::container = "type::container"c;
const type::empty = "type::empty"c;

(tuple) reverse_list(tuple list) impure {
  tuple old_list = list;
  tuple new_list = empty_tuple();

  while (old_list.tlen() > 0) {
    new_list = cons(old_list~list_next(), new_list);
  }

  return new_list;
}

;; ;; basic
;; hashTreeRoot(value: V): Uint8Array {
;;     // TODO: Optimize
;;     const uint8Array = new Uint8Array(32);
;;     const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
;;     this.value_serializeToBytes({uint8Array, dataView}, 0, value);
;;     return uint8Array;
;;   }

;; ;; bitList
;; hashTreeRoot(value: BitArray): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.bitLen);
;;   }



;; ;; byteList
;; hashTreeRoot(value: ByteArray): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; composite
;; hashTreeRoot(value: V): Uint8Array {
;;     // Return cached mutable root if any
;;     if (this.cachePermanentRootStruct) {
;;       const cachedRoot = (value as ValueWithCachedPermanentRoot)[symbolCachedPermanentRoot];
;;       if (cachedRoot) {
;;         return cachedRoot;
;;       }
;;     }

;;     const root = merkleize(this.getRoots(value), this.maxChunkCount);

;;     if (this.cachePermanentRootStruct) {
;;       (value as ValueWithCachedPermanentRoot)[symbolCachedPermanentRoot] = root;
;;     }

;;     return root;
;;   }



;; ;; listBasic
;; hashTreeRoot(value: ValueOf<ElementType>[]): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; listComposite
;; hashTreeRoot(value: ValueOf<ElementType>[]): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.length);
;;   }

;; ;; union
;; hashTreeRoot(value: ValueOfTypes<Types>): Uint8Array {
;;     return mix_in_length(super.hashTreeRoot(value), value.selector);
;;   }

;; (leaf: Buffer, branch: Buffer[], depth: number, index: number, root: Buffer)
;; (slice) int_to_slice(value: int) {
;;   return begin_cell()
;;   .store_uint(value, 32 * 8)
;;   .end_cell().begin_parse();
;; }

(int) is_valid_merkle_branch (int leaf, tuple branch, int depth, int index, int root) impure {
  int value = leaf;
  int powRes = 1;

  repeat(depth) {
    slice value_slice = begin_cell().store_uint(value, 32 * 8).end_cell().begin_parse();
    if ((index / powRes) % 2 == 1) {
      value = sha_hash_2(branch~tpop(),value_slice);
    } else {
      value = sha_hash_2(value_slice, branch~tpop());
    }
    powRes = powRes * 2;
  }

  return (value == root) % 2;
}

(tuple) fill_tuple(tuple fill, cell data, int count) impure {
  slice cs = data.begin_parse();
  int value = cs~load_uint(32 * 8);
  count += 1;
  fill = cons(value, fill);
  ;; fill = fill.tpush(value);
  if (cs.slice_refs_empty?() == 0) {
    return fill_tuple(fill, cs~load_ref(), count);
  }
  return cons(count, fill);
}

(slice, slice) hashTreeRoot(slice cs) impure {
  ;; slice cs = value.begin_parse();
  int data_type = cs~load_uint(32);

  cell log_body = begin_cell()
        .store_uint(data_type, 32)
        .store_ref(
          begin_cell()
            .store_uint(cs.slice_refs(), 16)
          .end_cell()
        )
        .end_cell();

  emit_log_simple(log::wrap, log_body, 0);

  if (data_type == type::bool) {
    int data = cs~load_uint(1);
    return (cs, begin_cell()
    .store_uint(data, 8)
    .store_uint(0, 31 * 8)
    .end_cell()
    .begin_parse());
  }

  if (data_type == type::uint) {
    int isInf = cs~load_uint(1);
    int size = cs~load_uint(16);
    int data = cs~load_uint(size * 8);

    if (size == 1) {
      return (cs, begin_cell()
      .store_uint(data, size * 8)
      .store_uint(0, 31 * 8)
      .end_cell().begin_parse());
    }
    if (size == 2) {
      return (cs, begin_cell()
      .store_uint(data & 0xFF, 8)
      .store_uint(data / 0x100, 8)
      .store_uint(0, 30 * 8)
      .end_cell().begin_parse());
    }
    if (size == 4) {
      return (cs, begin_cell()
      .store_endian4(data)
      .store_uint(0, 28 * 8)
      .end_cell().begin_parse());
    }
    if (size == 8) {
      ;; if (isInf) {
      ;;   data = 0xffffffffffffffff;
      ;; }

      return (cs, begin_cell()
      .store_endian8(data)
      .store_uint(0, 24 * 8)
      .end_cell().begin_parse());
    }
  }
  if ((data_type == type::byteList)) {
    cell start = cs~load_ref();
    int padFor = cs~load_uint(32);
    int valueLength = cs~load_uint(64);
    int count = 0;
    tuple filled = fill_tuple(empty_tuple(), start, count);
    count = filled~list_next();

    int res = merkleize(filled, padFor, count);
    res = mix_in_length(res, valueLength);

    return (
      cs,
      begin_cell()
        .store_uint(res, 32 * 8)
      .end_cell()
      .begin_parse()
    );
  }

  if ((data_type == type::byteVector)) {
    cell start = cs~load_ref();
    int padFor = cs~load_uint(32);
    int valueLength = cs~load_uint(64);
    int count = 0;
    tuple filled = fill_tuple(empty_tuple(), start, count);
    count = filled~list_next();

    int res = merkleize(filled, padFor, count);
    ;; res = mix_in_length(res, valueLength);

    return (
      cs,
      begin_cell()
        .store_uint(res, 32 * 8)
      .end_cell()
      .begin_parse()
    );
  }

  if (data_type == type::container) {
    cell fields = cs~load_ref();
    tuple chunks = empty_tuple();

    int count = 0;
    slice fields_slice = fields.begin_parse();

    slice field_res = fields_slice~hashTreeRoot();
    int field_hash = field_res~load_uint(32 * 8);
    chunks = cons(field_hash, chunks);
    count += 1;

    while (fields_slice.slice_refs_empty?() == 0) {
      fields = fields_slice~load_ref();
      fields_slice = fields.begin_parse();

      slice field_res = fields_slice~hashTreeRoot();
      int field_hash = field_res~load_uint(32 * 8);

      chunks = cons(field_hash, chunks);
      count += 1;
    }

    int res = merkleize(chunks, count, count);

    return (cs, begin_cell()
    .store_uint(res, 32 * 8)
    .end_cell().begin_parse());
  }

  if (data_type == type::list) {
    cell fields = cs~load_ref();
    tuple chunks = empty_tuple();
    int valueLength = cs~load_uint(64);
    int isEmpty = cs~load_uint(1);

    int count = 0;
    if (isEmpty == 0) {
      slice fields_slice = fields.begin_parse();

      slice field_res = fields_slice~hashTreeRoot();
      int field_hash = field_res~load_uint(32 * 8);
      chunks = cons(field_hash, chunks);
      count += 1;

      while (fields_slice.slice_refs_empty?() == 0) {
        fields = fields_slice~load_ref();
        fields_slice = fields.begin_parse();

        slice field_res = fields_slice~hashTreeRoot();
        int field_hash = field_res~load_uint(32 * 8);

        chunks = cons(field_hash, chunks);
        count += 1;
      }
    }

    int res = merkleize(chunks, valueLength, count);
    res = mix_in_length(res, count);

    cell log_body = begin_cell()
        .store_uint(0x9999, 16)
        .store_uint(res, 32 * 8)

        .end_cell();

    emit_log_simple(log::wrap, log_body, 0);

    return (cs, begin_cell()
    .store_uint(res, 32 * 8)
    .end_cell().begin_parse());
  }

  if (data_type == type::vector) {
    cell fields = cs~load_ref();
    tuple chunks = empty_tuple();
    int valueLength = cs~load_uint(64);
    int isEmpty = cs~load_uint(1);

    int count = 0;
    if (isEmpty == 0) {
      slice fields_slice = fields.begin_parse();

      slice field_res = fields_slice~hashTreeRoot();
      int field_hash = field_res~load_uint(32 * 8);
      chunks = cons(field_hash, chunks);
      count += 1;

      cell log_body = begin_cell()
        .store_uint(0x1111, 16)
        .store_uint(field_hash, 32 * 8)

        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);

      while (fields_slice.slice_refs_empty?() == 0) {
        fields = fields_slice~load_ref();
        fields_slice = fields.begin_parse();

        slice field_res = fields_slice~hashTreeRoot();
        int field_hash = field_res~load_uint(32 * 8);

        cell log_body = begin_cell()
        .store_uint(0x1111, 16)
        .store_uint(field_hash, 32 * 8)

        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);

        chunks = cons(field_hash, chunks);
        count += 1;
      }
    }



    int res = merkleize(reverse_list(chunks), valueLength, count);
    ;; res = mix_in_length(res, count);

    cell log_body = begin_cell()
        .store_uint(0x9999, 16)
        .store_uint(res, 32 * 8)
        .store_uint(count, 16)
        .store_uint(valueLength, 16)

        .end_cell();

    emit_log_simple(log::wrap, log_body, 0);

    return (cs, begin_cell()
    .store_uint(res, 32 * 8)
    .end_cell().begin_parse());
  }

  if (data_type == type::bitList) {
    int bitLimit = cs~load_uint(128);
    int bitLen = cs~load_uint(256);
    cell start = cs~load_ref();

    int count = 0;
    tuple filled = fill_tuple(empty_tuple(), start, count);
    count = filled~list_next();

    int valueLength = (bitLimit / 8) / 32;
    int res = merkleize(filled, valueLength, count);
    res = mix_in_length(res, bitLen);

    return (cs, begin_cell()
    .store_uint(res, 32 * 8)
    .end_cell().begin_parse());
  }

  if (data_type == type::bitVector) {
    int bitLimit = cs~load_uint(128);
    ;; int bitLen = cs~load_uint(256);
    cell start = cs~load_ref();

    int count = 0;
    tuple filled = fill_tuple(empty_tuple(), start, count);
    count = filled~list_next();

    int valueLength = (bitLimit / 8) / 32;
    int res = merkleize(filled, valueLength, count);
    ;; res = mix_in_length(res, bitLen);

    return (cs, begin_cell()
    .store_uint(res, 32 * 8)
    .end_cell().begin_parse());
  }

  if (data_type == type::empty) {
    return (cs, begin_cell()
    .store_uint(0, 32 * 8)
    .end_cell().begin_parse());
  }

  throw(1111);
  return (cs, begin_cell().end_cell().begin_parse());
}

(tuple) branch_to_tuple(slice branch) impure {
  tuple t = empty_tuple();
  slice items = branch~load_ref().begin_parse();

  while(items.slice_refs_empty?() == 0) {
    t = t.tpush(items~load_ref().begin_parse());
    if(items.slice_refs_empty?() == 0) {
      items = items~load_ref().begin_parse();
    }
  }
  return t;
}

(tuple) committee_branch_to_tuple(slice branch) impure {
  tuple t = empty_tuple();
  slice items = branch;

  t = t.tpush(items);
  while(items.slice_refs_empty?() == 0) {
    items = items~load_ref().begin_parse();
    t = t.tpush(items);
  }
  return t;
}

(int) aggregatePubkeyHashTreeRoot(slice cs) impure {
  int padFor = 2;
  int count = 2;
  tuple filled = empty_tuple();
  int part1 = cs~load_uint(32 * 8);
  int part2 = cs~load_uint(16 * 8) << (16 * 8);
  filled = cons(part1, filled);
  filled = cons(part2, filled);

  ;; cell log_body = begin_cell()
  ;;       .store_uint(part1, 32 * 8)
  ;;       .store_uint(part2, 32 * 8)
  ;;       .end_cell();

  ;;       emit_log_simple(log::wrap, log_body, 0);

  int res = merkleize(filled, padFor, count);
  return res;
}

(int) next_sync_committee_pubkeys_hash_tree_root(slice cs) impure {
  cell pubkeys = cs~load_dict();
  ;; calculate hash of pubkeys
  int i = 0;

  ;; (slice pub, int key) = pubkeys.udict_get?(32,i);
  ;; (int key, slice pub, int flag) = pubkeys.udict_get_max?(32);
  ;; cell log_body = begin_cell()
  ;;   .store_uint(0x010101, 32)
  ;;   ;; .store_uint(key & 0xffff, 128)
  ;;   .store_slice(pub)
  ;;   .end_cell();

  ;; emit_log_simple(log::wrap, log_body, 0);

  repeat(512) {
    (slice pub, int key) = pubkeys.udict_get?(32,i);
    int hash = aggregatePubkeyHashTreeRoot(pub);
    ;; begin_cell().store_uint(hash, 32 * 8).end_cell().begin_parse()
    ;; pubkeys~udict_replace?(32,i,"F");
    ;; pubkeys~udict_set(32, i, "F");
  }
  return 0;
  ;; return merkelize_dict(pubkeys,2,512);
}

(int) verify_sync_comittee(slice cs, slice committee_slice, slice committee_pubs_slice) impure {
  slice attested_header = cs~load_ref().begin_parse();
  slice attested_header_fields = attested_header~load_ref().begin_parse();

  slice finalized_header = attested_header~load_ref().begin_parse();
  slice finalized_header_fields = finalized_header~load_ref().begin_parse();

  slice beacon = attested_header_fields~load_ref().begin_parse();
  ;; slice beacon_fields = beacon~load_ref().begin_parse();
  slice execution = attested_header_fields~load_ref().begin_parse();
  (slice next_field, slice execution_ssz_hash) = hashTreeRoot(execution);
  slice execution_fields = execution~load_ref().begin_parse();
  slice executionBranch = execution~load_ref().begin_parse();

  int execution_branch_length = 5;
  int index = 23;

  slice beacon_slot = beacon~load_ref().begin_parse();
  slice beacon_proposer_index = beacon_slot~load_ref().begin_parse();
  slice beacon_parent_root = beacon_proposer_index~load_ref().begin_parse();

  slice beacon_state_root = beacon_proposer_index~load_ref().begin_parse();
  slice beacon_state_root_data = beacon_state_root~load_ref().begin_parse();
  slice beacon_body_root = beacon_state_root~load_ref().begin_parse();
  slice beacon_body_root_data = beacon_body_root~load_ref().begin_parse();



  ;; slice res = beacon_state_root_data;
  tuple committee_bracch_tuple = committee_branch_to_tuple(committee_slice);

  int res = is_valid_merkle_branch(
    committee_pubs_slice~load_uint(32 * 8),
    committee_bracch_tuple,
    execution_branch_length,
    index,
    beacon_state_root_data~load_uint(32 * 8));


  cell log_body = begin_cell()
        ;; .store_slice(res)
        .store_uint(res, 32)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);

  return res;
}

(int) verify_receipt_root(slice cs) impure {
  ;; skip attestedHeader body

  slice attested_header = cs~load_ref().begin_parse();
  slice attested_header_fields = attested_header~load_ref().begin_parse();

  slice finalized_header = attested_header~load_ref().begin_parse();
  slice finalized_header_fields = finalized_header~load_ref().begin_parse();

  slice beacon = finalized_header_fields~load_ref().begin_parse();
  ;; slice beacon_fields = beacon~load_ref().begin_parse();
  slice execution = finalized_header_fields~load_ref().begin_parse();
  (slice next_field, slice execution_ssz_hash) = hashTreeRoot(execution);
  slice execution_fields = execution~load_ref().begin_parse();
  slice executionBranch = execution~load_ref().begin_parse();

  int execution_branch_length = 4;
  int index = 9;

  slice beacon_slot = beacon~load_ref().begin_parse();
  slice beacon_proposer_index = beacon_slot~load_ref().begin_parse();
  slice beacon_parent_root = beacon_proposer_index~load_ref().begin_parse();

  slice beacon_state_root = beacon_proposer_index~load_ref().begin_parse();
  beacon_state_root~load_ref();
  slice beacon_body_root = beacon_state_root~load_ref().begin_parse();
  slice beacon_body_root_data = beacon_body_root~load_ref().begin_parse();


  int res = is_valid_merkle_branch(execution_ssz_hash~load_uint(32 * 8), branch_to_tuple(executionBranch), execution_branch_length, index, beacon_body_root_data~load_uint(32 * 8));

  ;; tuple test = branch_to_tuple(executionBranch);

  ;; slice res = test~tpop();

  cell log_body = begin_cell()
        ;; .store_slice(res)
        .store_uint(res, 32)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);

  return res;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    if (op == op::run_ssz) {
      cell data = in_msg_body~load_ref();
      slice data_slice = data.begin_parse();

      slice res = data_slice~hashTreeRoot();

      cell log_body = begin_cell()
        ;; .store_uint(res, 32)
        .store_slice(res)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);
      return();
    }

    if (op == op::run_verify_receipt) {
      cell data = in_msg_body~load_ref();
      slice data_slice = data.begin_parse();
      cell committee_cell = in_msg_body~load_ref();
      slice committee_slice = committee_cell.begin_parse();
      cell committee_pubs = in_msg_body~load_ref();
      slice committee_pubs_slice = committee_pubs.begin_parse();
      cell committee_full = in_msg_body~load_ref();
      slice committee_full_slice = committee_full.begin_parse();

      int res1 = verify_receipt_root(data_slice);
      int res2 = verify_sync_comittee(data_slice, committee_slice, committee_pubs_slice);

      ;; committee_full_slice~load_ref();
      int res3 = aggregatePubkeyHashTreeRoot(committee_full_slice);
      cell pubkeys_dict = committee_full_slice~load_ref();
      int res4 = next_sync_committee_pubkeys_hash_tree_root(pubkeys_dict.begin_parse());
      cell log_body = begin_cell()
        ;; .store_uint(res1, 8)
        ;; .store_uint(res2, 8)
        .store_uint(res4, 32 * 8)
        ;; .store_slice(committee_full_slice)
        .end_cell();

        emit_log_simple(log::wrap, log_body, 0);




      return ();
    }

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}
